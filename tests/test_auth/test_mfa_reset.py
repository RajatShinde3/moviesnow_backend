# tests/test_auth/test_mfa_reset.py

import pytest
from httpx import AsyncClient
from datetime import datetime, timedelta, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from unittest.mock import AsyncMock, patch

from app.db.models import MFAResetToken, User

# If you mounted the router with app.include_router(mfa_reset.router, prefix="/api/v1"),
# then this is correct. If you mounted under /api/v1/auth/mfa, change BASE accordingly.
BASE = "/api/v1/auth/mfa"


# ─────────────────────────────────────────────────────────────
# /mfa/request-mfa-reset
# ─────────────────────────────────────────────────────────────

@pytest.mark.anyio
async def test_request_mfa_reset_mfa_enabled(async_client: AsyncClient, db_session: AsyncSession, create_test_user):
    """
    ✅ When MFA is enabled for the user, return a neutral 200 AND internally
       create a reset token + schedule email.
    """
    user = await create_test_user(email="reset1@example.com", mfa_enabled=True)

    with patch("app.services.auth.mfa_reset_service.send_email", new_callable=AsyncMock) as mocked_send:
        resp = await async_client.post(f"{BASE}/request-mfa-reset", json={"email": user.email})

    assert resp.status_code == 200
    assert resp.json() == {
        "message": "If an account with that email exists, an MFA reset link has been sent."
    }
    # BackgroundTasks schedules the function; in tests it usually runs, but assert "called" is robust.
    assert mocked_send.called

    # Verify a token row was created for that user
    rows = (
        await db_session.execute(
            select(MFAResetToken).where(MFAResetToken.user_id == user.id, MFAResetToken.used == False)  # noqa: E712
        )
    ).scalars().all()
    assert len(rows) == 1
    assert rows[0].expires_at > datetime.now(timezone.utc)


@pytest.mark.anyio
async def test_request_mfa_reset_unknown_email_neutral_200(async_client: AsyncClient):
    """
    ✅ Unknown email → neutral 200 (no enumeration).
    """
    resp = await async_client.post(f"{BASE}/request-mfa-reset", json={"email": "notfound@example.com"})
    assert resp.status_code == 200
    assert resp.json() == {
        "message": "If an account with that email exists, an MFA reset link has been sent."
    }


# ─────────────────────────────────────────────────────────────
# /mfa/confirm-mfa-reset
# ─────────────────────────────────────────────────────────────

@pytest.mark.anyio
async def test_confirm_mfa_reset_success(async_client: AsyncClient, db_session: AsyncSession, create_test_user):
    """
    ✅ Valid token → MFA disabled, secret cleared, token marked used.
    """
    user = await create_test_user(email="reset2@example.com", mfa_enabled=True)

    token_obj = MFAResetToken(
        user_id=user.id,
        # token value will be auto-generated by model default if omitted; explicit is fine too
        expires_at=datetime.now(timezone.utc) + timedelta(minutes=10),
        used=False,
    )
    db_session.add(token_obj)
    await db_session.commit()
    await db_session.refresh(token_obj)

    resp = await async_client.post(
        f"{BASE}/confirm-mfa-reset",
        json={"token": str(token_obj.token)},
    )

    assert resp.status_code == 200
    assert resp.json()["message"].startswith("MFA has been reset")

    # Token is used
    await db_session.refresh(token_obj)
    assert token_obj.used is True

    # User MFA is disabled + secret cleared
    refreshed_user = await db_session.get(User, user.id)
    await db_session.refresh(refreshed_user)
    assert refreshed_user.mfa_enabled is False
    assert refreshed_user.totp_secret is None


@pytest.mark.anyio
async def test_confirm_mfa_reset_invalid_token(async_client: AsyncClient):
    """
    ❌ Garbage/unknown token → 400 Invalid/Expired.
    """
    resp = await async_client.post(
        f"{BASE}/confirm-mfa-reset",
        json={"token": "invalid-token"},
    )
    assert resp.status_code == 400
    assert "Invalid or expired token" in resp.json()["detail"]


@pytest.mark.anyio
async def test_confirm_mfa_reset_expired_token(async_client: AsyncClient, db_session: AsyncSession, create_test_user):
    """
    ❌ Token exists but is expired → 400.
    """
    user = await create_test_user(email="reset3@example.com", mfa_enabled=True)

    token_obj = MFAResetToken(
        user_id=user.id,
        expires_at=datetime.now(timezone.utc) - timedelta(seconds=1),
        used=False,
    )
    db_session.add(token_obj)
    await db_session.commit()
    await db_session.refresh(token_obj)

    resp = await async_client.post(
        f"{BASE}/confirm-mfa-reset",
        json={"token": str(token_obj.token)},
    )
    assert resp.status_code == 400
    assert "Invalid or expired token" in resp.json()["detail"]


@pytest.mark.anyio
async def test_confirm_mfa_reset_already_used_token(async_client: AsyncClient, db_session: AsyncSession, create_test_user):
    """
    ❌ Token already used → 400.
    """
    user = await create_test_user(email="reset4@example.com", mfa_enabled=True)

    token_obj = MFAResetToken(
        user_id=user.id,
        expires_at=datetime.now(timezone.utc) + timedelta(minutes=5),
        used=True,  # already used
    )
    db_session.add(token_obj)
    await db_session.commit()
    await db_session.refresh(token_obj)

    resp = await async_client.post(f"{BASE}/confirm-mfa-reset", json={"token": str(token_obj.token)})
    assert resp.status_code == 400
    assert "Invalid or expired token" in resp.json()["detail"]


@pytest.mark.anyio
async def test_confirm_mfa_reset_missing_body(async_client: AsyncClient):
    """
    ❌ Pydantic validation: missing 'token' field → 422.
    """
    resp = await async_client.post(f"{BASE}/confirm-mfa-reset", json={})
    assert resp.status_code == 422
